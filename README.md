## üìä Tabela: Conceitos de Programa√ß√£o Funcional em C#

| Conceito                         | Descri√ß√£o T√©cnica                                                                 | Prop√≥sito Pr√°tico                                                                                  |
|----------------------------------|------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|
| **Fun√ß√£o Pura**                  | Fun√ß√£o que n√£o depende de ou modifica estado externo.                             | Facilita testes unit√°rios e concorr√™ncia segura.                                                    |
| **Imutabilidade**                | Dados n√£o s√£o modificados ap√≥s sua cria√ß√£o.                                       | Evita efeitos colaterais e simplifica o racioc√≠nio sobre o estado do sistema.                      |
| **Fun√ß√µes de Ordem Superior**    | Fun√ß√µes que recebem ou retornam outras fun√ß√µes (`Func`, `Action`, `Predicate`).   | Permite reutiliza√ß√£o e composi√ß√£o de l√≥gica.                                                        |
| **Currying**                     | Transforma√ß√£o de uma fun√ß√£o de m√∫ltiplos argumentos em uma cadeia de fun√ß√µes un√°rias. | Torna fun√ß√µes mais reutiliz√°veis e compat√≠veis com `Partial Application`.                         |
| **Partial Application**          | Fixar um ou mais par√¢metros de uma fun√ß√£o, criando uma nova fun√ß√£o com menos argumentos. | Especializa fun√ß√µes de forma incremental.                                                          |
| **Composi√ß√£o de Fun√ß√µes**       | Combinar duas ou mais fun√ß√µes em uma √∫nica, aplicando uma ap√≥s a outra.           | Modulariza pipelines de dados e l√≥gica.                                                            |
| **Option (Maybe Monad)**         | Representa presen√ßa ou aus√™ncia de valor sem usar `null`.                         | Elimina o uso de `null` e facilita controle de fluxo.                                               |
| **Either (Erro Funcional)**      | Representa valor de sucesso (`Right`) ou erro (`Left`).                           | Modela erros como valores previs√≠veis ao inv√©s de lan√ßar exce√ß√µes.                                 |
| **Map**                          | Aplica uma fun√ß√£o sobre o valor interno de um `Option`, `Either`, `List`, etc.     | Transforma valores encapsulados de forma segura.                                                   |
| **Bind (FlatMap / SelectMany)**  | Encadeia fun√ß√µes que retornam tipos elevados (`Option`, `Either`, etc.).           | Permite criar pipelines funcionais com controle de fluxo robusto.                                  |
| **LINQ Funcional**               | Uso de `Where`, `Select`, `Aggregate`, etc. sobre `IEnumerable` como fun√ß√µes puras. | Facilita o processamento funcional sobre cole√ß√µes.                                                  |
| **Recurs√£o (tail recursion)**    | Repeti√ß√£o baseada em chamada de fun√ß√£o a si mesma.                                | Evita uso de loops imperativos (com suporte limitado em C# sem TCO).                              |
| **Lazy Evaluation**              | Avalia√ß√£o de express√µes apenas quando necess√°rio (`Lazy<T>`, `yield return`).     | Aumenta performance em cole√ß√µes ou c√°lculos pesados e potencialmente infinitos.                    |
| **Monads**                       | Padr√£o para encadear opera√ß√µes em tipos elevados (`Option`, `Either`, `Task`, etc.). | Uniformiza encadeamentos seguros e previs√≠veis em contextos com efeitos colaterais.               |
| **Expression Trees**             | Representam fun√ß√µes como dados (`Expression<Func<T>>`).                           | Permite compor, serializar ou executar express√µes de forma din√¢mica (ex: EF Core, LINQ).           |
